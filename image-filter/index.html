<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <canvas id="gpu-canvas"></canvas>
    <div class="log-wrapper">
      <div class="log"></div>
      <div>click to load random pic</div>
    </div>
    <input type="file" accept="image/*" style="display: none" />

    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.19"></script>
    <script type="module">
      import { basicFilterShader } from './shaders/basicFilter.js';
      import { loadImageBitmap, getRandomImageUrl } from './imageLoader.js';
      import { logMessage } from './logElement.js';

      const settings = {
        brightness: 0,
        contrast: 0,
        exposure: 0,
        gammaCompInShader: false,
        format: 'rgba8unorm',
        imageURL: getRandomImageUrl(),
      };

      let currentBitmap, useCurrentBitmap;

      const { device, context, format, canvas } = await initWebGPU();
      const { pipeline, sampler } = buildPipeline();
      let bindGroup;
      const uniformBuffer = device.createBuffer({
        size: 4 * 8,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      });

      updateUniforms();
      createGUI();

      await updateTexture();
      frame();

      canvas.onclick = function () {
        settings.imageURL = getRandomImageUrl();
        updateTexture();
      };

      async function initWebGPU() {
        if (!navigator.gpu) throw new Error('WebGPU not supported');
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) throw new Error('No GPU adapter found');
        const device = await adapter.requestDevice();
        const canvas = document.getElementById('gpu-canvas');
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();
        return { device, context, format, canvas };
      }

      async function createTextureFromImage(device, url) {
        let img;
        if (useCurrentBitmap) {
          img = currentBitmap;
          useCurrentBitmap = false;
        } else {
          img = await loadImageBitmap(url);
          currentBitmap = img;
        }
        const texture = device.createTexture({
          size: [img.width, img.height],
          format: settings.format,
          usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
        });
        device.queue.copyExternalImageToTexture({ source: img, flipY: true }, { texture }, [img.width, img.height]);
        return texture;
      }

      async function updateTexture() {
        logMessage('Loading image...');
        canvas.style.opacity = '0.15';
        const texture = await createTextureFromImage(device, settings.imageURL);
        logMessage(`Image loaded: ${texture.width} Ã— ${texture.height}`);
        canvas.style.opacity = '1';

        resizeCanvas(texture.width, texture.height);

        bindGroup = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: sampler },
            { binding: 1, resource: texture.createView() },
            { binding: 2, resource: { buffer: uniformBuffer } },
          ],
        });
      }

      function buildPipeline() {
        const module = device.createShaderModule({
          code: basicFilterShader,
        });

        const sampler = device.createSampler({ magFilter: 'linear', minFilter: 'linear' });
        const bindGroupLayout = device.createBindGroupLayout({
          entries: [
            {
              binding: 0,
              visibility: GPUShaderStage.FRAGMENT,
              sampler: {},
            },
            {
              binding: 1,
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
              texture: {},
            },
            {
              binding: 2,
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
              buffer: { type: 'uniform' },
            },
          ],
        });

        const pipelineLayout = device.createPipelineLayout({
          bindGroupLayouts: [bindGroupLayout],
        });

        const pipeline = device.createRenderPipeline({
          layout: pipelineLayout,
          vertex: {
            module,
            entryPoint: 'vs',
          },
          fragment: {
            module,
            entryPoint: 'fs',
            targets: [{ format }],
          },
          primitive: { topology: 'triangle-strip' },
        });

        return { pipeline, sampler, bindGroupLayout };
      }

      function resizeCanvas(w, h) {
        canvas.width = w;
        canvas.height = h;
        context.configure({
          device,
          format,
          alphaMode: 'premultiplied',
        });
      }

      function updateUniforms() {
        const { brightness, contrast, exposure, gammaCompInShader } = settings;
        device.queue.writeBuffer(
          uniformBuffer,
          0,
          new Float32Array([brightness, contrast, exposure, gammaCompInShader ? 1 : 0])
        );
      }

      function frame() {
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              clearValue: [0, 0, 0, 0],
              loadOp: 'clear',
              storeOp: 'store',
            },
          ],
        });

        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.draw(4);
        pass.end();

        device.queue.submit([encoder.finish()]);
        requestAnimationFrame(frame);
      }

      function createGUI() {
        const gui = new lil.GUI({ container: document.getElementById('gui-container') });
        const filterFolder = gui.addFolder('filter');
        const debugFolder = gui.addFolder('debug');
        filterFolder.add(settings, 'brightness', -1, 1, 0.01).onChange(updateUniforms);
        filterFolder.add(settings, 'contrast', -1, 1, 0.01).onChange(updateUniforms);
        filterFolder.add(settings, 'exposure', -1, 1, 0.01).onChange(updateUniforms);
        const fileInput = document.querySelector('input');
        fileInput.onchange = () => {
          settings.imageURL = fileInput.files?.[0];
          updateTexture();
        };
        filterFolder.add({ load: () => fileInput.click() }, 'load').name('load image from disk');

        debugFolder.add(settings, 'gammaCompInShader').onChange(updateUniforms);
        debugFolder.add(settings, 'format', ['rgba8unorm', 'rgba8unorm-srgb']).onChange(() => {
          useCurrentBitmap = true;
          updateTexture();
        });
      }
    </script>
  </body>
</html>
